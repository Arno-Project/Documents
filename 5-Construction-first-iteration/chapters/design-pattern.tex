\chapter{
الگوهای طراحی
}

در این فصل اجمالا الگوهای طراحی اصلی استفاده شده در پروژه ذکر شده است. الگوهای استفاده شده در بک‌اند در قسمت \ref{designpattern:back} و الگوهای استفاده شده در فرانت‌اند در قسمت \ref{designpattern:front} آورده شده‌اند.

\newpage
\section{بک‌اند}
\label{designpattern:back}

\begin{itemize}
	\item 
	\textbf{الگوی \lr{Singleton}}
	از این الگو برای کلاس‌هایی که می‌خواهیم تنها یک Instance از آن‌ها موجود باشد استفاده کرده‌ایم. استفاده اصلی آن برای کلاس‌های کاتالوگ (نظیر \lr{UserCatalogue}، \lr{RequestCatalogue} و...) بوده است که وظیفه جست‌وجو روی کلاس‌های نظیر خود را دارند. نحوه پیاده‌سازی این مورد به صورت تعریف یک کلاس \lr{Singleton} بوده است که بقیه کلاس‌ها با عملیاتی مشابه ارث‌بری از آن استفاده می‌کنند. البته به خاطر ساختار خاص پایتون، در اصل این فرآیند ارث‌بری مستقیم نیست و از طریق \lr{metaclass} مهیا شده است که تفاوت‌های اندکی در لایه درونی پیاده‌سازی پایتون با ارث‌بری دارد ولی در نمودارها به صورت ارث‌بری نشان داده شده است چون از نظر عملکردی مشابه ارث‌بری عمل می‌کند.
	
	\item 
	\textbf{الگوی \lr{Iterator}}
	این الگو عملا در سطح خود پایتون پیاده سازی شده است و به ما اجازه استفاده از \lr{for} روی \lr{Collection} های مختلف نظیر \lr{List} ها بدون نیاز به دسترسی مستقیم به اندیس‌های آن را می‌دهد. از آن جایی که در بسیاری از قسمت‌های مختلف که بر روی لیستی از رشته‌ها یا آی‌دی‌ها و آبجکت‌ها عملیاتی انجام شده است، از این الگو استفاده شده، در این قسمت آن را ذکر کرده ایم.
	
	\item 
	\textbf{الگوی \lr{Abstract Factory}}ی
	
	یکی از مواردی که در کد به آن نیاز داشتیم، \lr{Permission} های مختلف برای \lr{Endpoint} های گوناگون بود. نحوه هندل شدن این موضوع در جنگو به این صورت است که باید کلاسی که \lr{Permission} در آن تعریف شده است به عنوان پارامتری در یک لیست به کلاسی که ریکوئست را دریافت می‌کند داده بشود. از آن‌جایی که هر بار تعریف این کلاس‌ها و آن هم برای نقش‌های گوناگون باعث ایجاد \lr{Duplicate Code} بسیار زیادی می‌شد، ما از الگوی \lr{Abstract Factory} استفاده کردیم. در این الگو یک کلاس \lr{PermissionFactory} داریم که با دریافت نوع کاربری که باید برای آن \lr{Permission} تعریف بشود، کلاس پایتونی مد نظر برای آن را ایجاد کرده و به ما تحویل می‌دهد تا در قسمت‌های مختلف کد استفاده کنیم. بدین ترتیب فقط یک بار نحوه ایجاد این کلاس در \lr{PermissionFactory} نوشته شده و این \lr{PermissionFactory} است که وظیفه ایجاد این کلاس را بر عهده دارد.
	
	\item
	\textbf{الگوی \lr{Builder}}
	
	از این الگو برای ایجاد \lr{Notification} ها استفاده شده است. از آن جایی که متن درون هر \lr{Notification} به نوع آن \lr{Notification} و محل استفاده آن بستگی دارد ولی الگوی کلی ساخته شدن آن (یعنی تعریف عنوان، تعریف بدنه، تعریف کاربر و...) یکسان است، از الگوی \lr{Builder} استفاده شده است. در کلاس \lr{NotificationBuilder} مراحل مقداردهی پارامترهای مختلف \lr{Notification} انجام می‌شود و کلاس‌های مختلف \lr{Notification} بسته به نوع کاربردی که دارند، جزییات متن پیام و پارامترها را استخراج کرده و آن‌‌ها را در اختیار \lr{NotificationBuilder} قرار می‌دهند تا به ترتیبی که لازم است، آن‌ها را در کنار هم قرار داده و \lr{Notification} را ایجاد کند.
	
	
	\item
	\textbf{الگوی \lr{Adapter}}
	
	در بسیاری از قسمت‌هایی که سرچ انجام می‌شد، برای حالتی که \lr{ID} داده بشود، برای این که جامع‌ترین حالت پوشش داده بشود، از \lr{Syntax} ای که مخصوص جست‌وجو روی لیست است استفاده می‌شود که بتوانیم لیستی از \lr{ID} ها را داده و همه آن‌ها را تحویل بگیریم. نکته‌ای که وجود دارد این است که اگر از سمت فرانت‌اند درخواستی که برای بک‌اند می‌آید لیست نبوده و مثلا یک \lr{ID} تنها باشد، در \lr{Syntax} جنگو با مشکل مواجه می‌شویم چون انتظار لیست را داشته است. از آن‌جایی که این موضوع به کرات رخ می‌داد، برای این موضوع کلاسی به نام \lr{ListAdapter} تعریف کردیم . این کلاس تابعی به نام \verb+python_ensure_list+  داشته که یک ورودی گرفته و اگر \lr{list} باشد خود آن را بر می‌گرداند و اگر \lr{string} یا \lr{int} باشد، آن‌ را درون یک لیست تکی قرار داده و این \lr{list} را خروجی می‌دهد. بدین ترتیب نیازی به چک کردن‌های زیاد در قسمت‌هایی که انتظار ورودی دادن یک لیست را داریم نداشته و صرفا ورودی را به این \lr{Adapter} می‌دهیم تا در صورتی که در قالب مشخص ما نبود، آن را به قالبی که قابل استفاده باشد تبدیل کند.
	
	
	
\end{itemize}

\newpage

\section{فرانت‌اند}
\label{designpattern:front}


\begin{itemize}
	\item 
	\textbf{الگوی \lr{Observer}}
	در فرانت‌اند ما برای مدیریت \lr{State} از کتابخانه \lr{Redux} استفاده کرده‌ایم که عملا پیاده‌سازی‌ الگوی \lr{Observer} است. در \lr{Redux}، حالات مورد نیاز هر کدام از کامپوننت‌ها در مجموعه‌ای که به طور کلی \lr{Store} نامیده می‌شود قرار می‌گیرند و هر کدام از کامپوننت‌ها بسته به این که به کدام بخش از داده‌های درون \lr{Store} نیاز دارند، مشترک آن قسمت شده و در صورت تغییرات آن، از آن مطلع شده و تغییرات لازم در آن‌ها اعمال می‌شود.
	
	 
\end{itemize}